# Part 1: Physical Memory Management
Part 1的任务是实现物理内存管理，我们可以看到，相较lab1，i386_init多了一句话
```
void
i386_init(void)
{
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();

	cprintf("6828 decimal is %o octal!\n", 6828);

	// Lab 2 memory management initialization functions
	mem_init();

	// Drop into the kernel monitor.
	while (1)
		monitor(NULL);
}
```
多了一句mem_init()，这就是我们整个lab要解决的内容了
我们先想想，到这一步为止，我们有什么吧（我一开始就是没有想清楚到底已经做了什么才头有点晕）
首先，我们通过hard code将0x00000000-0x00400000与0x0xf0000000-0xf0400000，搞定了这共计8MB的地址空间。
内核在哪里呢？虚拟地址上来说是从0xf0100000开始，到end（也就是.bss段的结尾，在kernel.ld中定义，extern给C语言使用）为止，
而实际上在物理内存上，它在0x00100000开始处到(end-0xf0000000)上，也就是从第二MB开始。
前1MB的分布我们提过了，640KB的low memory，后面给I/O设备的部分，以及1MB最后留给了BIOS。
这就是物理内存的实际情况了，别的地方尚未使用。这一部分实验我们要做什么呢？
1. 询问CMOS到底插了多少内存
2. 给物理内存的每一个page都做一条记录，管理它们的使用和分配
3. 做到1，2的同时预留出来Page Directory Table的空间，留着后面使用

嗯，这样清晰多啦，我们来看看mem_init吧
```
// Find out how much memory the machine has (npages & npages_basemem).
i386_detect_memory();
```
首先是architect-dependant的内存询问，目的是设置这两个全局变量：
```
// These variables are set by i386_detect_memory()
size_t npages;			// Amount of physical memory (in pages)
static size_t npages_basemem;	// Amount of base memory (in pages)
```
总页数和基本内存（即low memeory）的页数

而后就是为Page Directory Table预留内存了，但是这个时候我们还没有建立起一套track物理内存页管理的机制，因此要在心中牢记这些分配出去的内存，到时候有物理页track机制了（马上有）要给它们标记为已用的。
```
// create initial page directory.
kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
memset(kern_pgdir, 0, PGSIZE);
```
这时候的分配因此就暂时用这个boot_alloc了：
```
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
```
参数为要分配的大小。可以看到这里对nextfree的初始化方法，就是对end按照页大小向上round，名副其实。实现就比较简单了，返回当前的nextfree值，而后按照页对其向后推进。而这里也可以看到，输入0的时候就是立即返回nextfree当前值了，而不会实际分配页。
```
	result=nextfree;
	nextfree=ROUNDUP((char*)(nextfree+n),PGSIZE);
```
这样我们就把临时的boot_alloc实现了。

后面一小段跳过，介绍的是页目录自指。我们开始track物理页。
首先要给这些记录物理页信息的entry(也就是Pageinfo结构)分配页，一个页一个（我们已经知道到底有多少物理内存了--npages），那还是用我们的小boot_alloc来：
```
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	size_t pageinfo_array_size=npages*sizeof(struct PageInfo);
	pages=(struct PageInfo*)boot_alloc(pageinfo_array_size);
	memset(pages,0,pageinfo_array_size); 
```
接下来我们就用这个pages array开启物理页track机制。首先我们来初始化它们，先看看Pageinfo的结构：
```
struct PageInfo {
	// Next page on the free list.
	struct PageInfo *pp_link;

	// pp_ref is the count of pointers (usually in page table entries)
	// to this page, for pages allocated using page_alloc.
	// Pages allocated at boot time using pmap.c's
	// boot_alloc do not have valid reference count fields.

	uint16_t pp_ref;
};
```
第一个pp_link（emmm这缩写...）指向下一个未分配页对应的entry，当这个entry对应的page被分配出去后，这个置NULL；第二个pp_ref是引用计数。简单明了~

那么很明显，我们要track页，就全局保留一个链表头，每个entry再指向下一个为分配页对应的entry就可以track了。那么先初始化信息。

根据我们之前的讨论以及BIOS的特性，有如下区域是被占用了的：
1. 物理内存的第一个page，被BIOS存储数据（中断向量表等等）用了
2. 640K到1MB被I/O device和BIOS映射了，无法访问到，相当于用了
3. 1MB到end-0xf0000000被内核用了（虽然虚拟地址是0xf0100000到end）
4. 虚拟地址上，从end开始我们刚分配了两次用，在物理地址上也就是从end-0xf0000000我们分配了两次，这些也被用了
总的来说，就是有两个离散的区域，一个是index=0的页，一个是从640K到最终刚分配完的这样一个连续区域（可以看出是连着的），因此初始化如下：
```
size_t i;

//identity initialization
for (i = 0; i < npages; i++) {
    pages[i].pp_ref = 0;
    pages[i].pp_link = pages+1+i;
}
pages[npages-1].pp_link=NULL;// final entry next to NULL
page_free_list=pages+1;	//linked list head points to index=1 entry

//set allocated status
pages[0].pp_ref=1;
pages[0].pp_link=NULL;

//set allocated status
size_t i_start=IOPHYSMEM/PGSIZE,i_end=ROUNDUP(PADDR(boot_alloc(0)),PGSIZE)/PGSIZE;
for(i=i_start;i<i_end;i++){
    pages[i].pp_ref=1;
    pages[i].pp_link=NULL;
}

//the next unallocated page with respect to index=i_start-1 is index=i_end
pages[i_start-1].pp_link=&pages[i_end];
```
中间的PADDR宏接收一个entry（也就是Pageinfo）指针，计算它代表的page的起始物理地址；另外注意最后一句指针操作让它们衔接起来。剩下的就是分配和释放操作，也就类似链表的插入删除同时更新链表头了，这个简单，直接贴这儿了：
```
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	if(!page_free_list)
		return NULL;
	
	struct PageInfo* retPageinfo=page_free_list;
	page_free_list=retPageinfo->pp_link;
	retPageinfo->pp_link=NULL;

	if(alloc_flags&ALLOC_ZERO)
		memset(page2kva(retPageinfo),0,PGSIZE);

	return retPageinfo;
}
```
```
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
	if(pp->pp_ref||pp->pp_link){
		panic("Fail to free page NO%d\n",pp-pages);
	}

	if((!page_free_list)||(pp<page_free_list)){
		pp->pp_link=page_free_list;
		page_free_list=pp;
	}else{
		struct PageInfo* freeptr=page_free_list;
		while ((freeptr->pp_link!=NULL)&&(freeptr->pp_link<pp))
			freeptr=freeptr->pp_link;
		pp->pp_link=freeptr->pp_link;
		freeptr->pp_link=pp;
	}
}
```
剩余就是把代码编译一下试着运行了
# But!!!!!!
这里有个坑，不知道为啥lab2的kern/kernel.ld被改了，原本关于.bss段的链接指令是这样的：
```
.bss : {
    PROVIDE(edata = .);
    *(.bss)
    PROVIDE(end = .);
    BYTE(0)
}
```
结果在这个lab里被改成了：
```
PROVIDE(edata = .);

.bss : {
    *(.bss)
}

PROVIDE(end = .);
```
这一改问题来大了，因为.bss前面是.data的链接指令，下面那种写法会把edata的值设为刚结束.data段的.值，也就是.data的结尾值，而上面那种写法会把edata的值设为刚开始.bss段的.值，而我们init刚开始时是干了这么一件事的...
```
extern char edata[], end[];

// Before doing anything else, complete the ELF loading process.
// Clear the uninitialized global data (BSS) section of our program.
// This ensures that all static/global variables start out zero.
memset(edata, 0, end - edata);
```
把.bss段的uninitialized区域0初始化，本意是仅仅初始化.bss段，但是写成下面那样会把从.data段结束的地址到.bss段结束的地址对应的内存全部置0，别忘了它们中间还有...
```
Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002739  f0100000  00100000  00001000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000a40  f0102740  00102740  00003740  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .stab         00005155  f0103180  00103180  00004180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .stabstr      00001d48  f01082d5  001082d5  000092d5  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00009300  f010b000  0010b000  0000c000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  5 .got          00000008  f0114300  00114300  00015300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .got.plt      0000000c  f0114308  00114308  00015308  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .data.rel.local 00001000  f0115000  00115000  00016000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data.rel.ro.local 00000044  f0116000  00116000  00017000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000654  f0116060  00116060  00017060  2**5
                  CONTENTS, ALLOC, LOAD, DATA
```
全没了...

所以这里要先去kern/kernel.ld把这代码改回去，不知道是不是lab的bug

所以说了这么多为啥我知道呢？踩坑了呗，调试了一个多小时一只内存出问题，去洗了个澡回来搜了下有个哥们儿提到了edata和end值的问题，这才回去找了出来这个.ld文件的问题，有点坑，略略略...